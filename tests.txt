# TEST

### Compile

- [x]  Use `make -n` to see if compilation use `-Wall -Wextra -Werror`. If not, select the "invalid compilation" flag.
- [x]  minishell compiles without any errors. If not, select the flag.
- [x]  The Makefile must not re-link. If not, select the flag.
- [x]  -g -O0
- [x]  `valgrind` and `-fsanitize=address`
- [x]  open minishell inside minishell and type ctrl+C
- [x]  **PASS?**

### Simple Command & global variables

- [x]  Execute a simple command with an absolute path like `/bin/ls`, or any other command without any options.
- [x]  How many global variables are used? Why? Ask the evaluated student to give you a concrete example of why it feels mandatory or logical.
- [x]  Test an empty command.
- [x]  Test only spaces or tabs.
- [x]  `'l's` & `""ls` // should work `set -- "abc""def"; echo $#` = 1 symbol on bash
- [x]  `$bad ls` // should run || WORKS
- [x]  `" "ls` or `"" ls` or `" ls"` // should not work
- `./some_dir`
    - [x]  `srcs` → `srcs: command not found`
    - [x]  `/srcs` → `bash: /srcs: No such file or directory`
    - [x]  `srcs/` → `bash: srcs/: Is a directory`
    - [x]  `./srcs` → `bash: ./srcs: Is a directory`
- `./some_file`
    - [x]  `test.txt` → `test.txt: command not found`
    - [x]  `/test.txt` → `bash: /test.txt: No such file or directory`
    - [x]  `test.txt/` → `bash: test.txt/: Not a directory`
    - [x]  `./test.txt` → `bash: ./test.txt: Permission denied`
- random input
    
    ```bash
    lawences@c1r1s10:~/sgoinfre/Minishell$ << > <><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `>'
    lawences@c1r1s10:~/sgoinfre/Minishell$ << >> <><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `>>'
    lawences@c1r1s10:~/sgoinfre/Minishell$ >> << >><><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `<<'
    lawences@c1r1s10:~/sgoinfre/Minishell$ > << >><><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `<<'
    lawences@c1r1s10:~/sgoinfre/Minishell$ >> << >><><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `<<'
    lawences@c1r1s10:~/sgoinfre/Minishell$ >> < |<>><><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `<'
    lawences@c1r1s10:~/sgoinfre/Minishell$ >> << |>><><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `<<'
    lawences@c1r1s10:~/sgoinfre/Minishell$ << >> |<><><><><<><><><<><<><><<><><>>a
    bash: syntax error near unexpected token `>>'
    ```
    
- [x]  `ls`
- [x]  **PASS?**

### Arguments

- [x]  Execute a simple command with an absolute path like `/bin/ls`, or any other command with arguments but without any quotes or double quotes.
- [x]  Repeat multiple times with different commands and arguments.
- [x]  **PASS?**

### echo

- [x]  Execute the echo command with or without arguments, or the -n option.
- [x]  Repeat multiple times with different arguments.
- [x]  `echo 'literal " char'` // is not an unclosed quote
- [x]  `echo hello$` → prints hello$
- [x]  `echo $bad$HOME` // prints HOME dir
- [x]  **PASS?**

### exit

- [x]  Execute exit command with or without arguments.
- [x]  Repeat multiple times with different arguments.
- [x]  `exit 90 90` // will not exit "too many args" -> exit code 1
- [x]  `exit word 90` // will exit but return an error -> exit code 2
- [x]  `exit 9223372036854775807` → exits with code 255
- [x]  `exit 9223372036854775808` → numeric error and exits with 2
- [x]  `exit -9223372036854775808` → exits with code 0
- [x]  `exit -9223372036854775809` → num error exits w code 2
// check with echo $SHLVL → prints current shell level
- [x]  `exit 00000000000000000000000001` // should work
- [x]  `exit +001` // ok
- [x]  `exit ++001` // bad
- [x]  **PASS?**

### Return value of a process

- [x]  Execute a simple command with an absolute path like `/bin/ls`, or any other command with arguments but without any quotes and double quotes. Then execute `echo $?`
- [x]  Check the printed value. You can do the same in bash in order to compare the results.
- [x]  Repeat multiple times with different commands and arguments. Try some wrong commands like '/bin/ls filethatdoesntexist'
- [ ]  Try anything like `expr $? + $?`
- [x]  `false` // should update exit to 1
- [ ]  **PASS?**

### Signals

- [x]  ctrl-C in an empty prompt should display a new line with a new prompt.
- [x]  ctrl-\ in an empty prompt should not do anything.
- [x]  ctrl-D in an empty prompt should quit minishell --> RELAUNCH!
- [x]  ctrl-C in a prompt after you wrote some stuff should display a new line with a new prompt.
- [x]  The buffer should be clean too. Press "Enter" to make sure nothing from the previous line is executed.
- [x]  ctrl-D in a prompt after you wrote some stuff should not do anything.
- [x]  ctrl-\ in a prompt after you wrote some stuff should not do anything.
- [x]  Try ctrl-C after running a blocking command like cat without arguments or grep “something“.
- [x]  Try ctrl-\ after running a blocking command like cat without arguments or grep “something“.
- [x]  Try ctrl-D after running a blocking command like cat without arguments or grep “something“.
- [x]  Repeat multiple times using different commands.
- [x]  ctrl+C on terminal → `echo $?` should return 130
- [x]  **PASS?**

### Double Quotes

- [x]  Execute a simple command with arguments and, this time, use also double quotes (you should try to include whitespaces too).
- [x]  Try a command like : `echo "cat lol.c | cat > lol.c"`
- [x]  Try anything except $.
- [x]  **PASS?**

### Single Quotes

- [x]  Execute commands with single quotes as arguments.
- [x]  Try empty arguments.
- [x]  Try environment variables, whitespaces, pipes, redirection in the single quotes.
- [x]  echo `'$USER'` must print $USER.
- [x]  Nothing should be interpreted.
- [x]  `"a 'bad" phrase'` // overlapping quotes = unclosed quotes
    - [x]  ' // test with a single quote mark only
- [x]  **PASS?**

### env

- [x]  Check if env shows you the current environment variables
- [x]  env -i ./minishell
    
    ![WhatsApp Image 2025-06-16 at 16.52.58_7e6c12ff.jpg](attachment:a2c80b1c-c98a-4804-8cbb-c9fc6eebf7bf:WhatsApp_Image_2025-06-16_at_16.52.58_7e6c12ff.jpg)
    
- [x]  **PASS?**

### export

- [x]  Export environment variables, create new ones and replace old ones.
- [x]  Check the result with env.
- [x]  `export test=s` → `l$test` // should run ls
- [x]  `export c b="" a=test` // export shows quotes and in ASCII order and empty vars
- [x]  `export a`, open new minishell, check it didn't import this var.
- [x]  `export HOME=` → `cd` // doesn't change directory and no message
- [x]  `export | cat PWD` // with valgrind
- [x]  **PASS?**

### unset

- [x]  Export environment variables, create new ones and replace old ones.
- [x]  Use unset to remove some of them.
- [x]  `unset HOME` → `cd` // home not set
    - [x]  `export HOME=` → `cd` // do nothing
- [x]  `unset PATH` → `ls` -> error should be No such file or directory
- [x]  `unset PATH` → `cd /bin/` → `ls` // should work in current directory
- [x]  Check the result with env
- [x]  `unset PWD` → `pwd` // should use getcwd not $PWD. export PWD=test and try
- [x]  `unset OLDPWD` → `cd ..` → `cd -` // should work
- [x]  `unset PWD` → `cd -` → `cd -` // should not work on the second try (OLDPWD not set)
- [x]  **PASS?**

### Environment variables

- [x]  Execute echo with some environment variables ($variable) as arguments.
- [x]  Check that `$` is interpreted as an environment variable.
- [x]  Check that double quotes interpolate `$`.
- [x]  Check that `USER` exists. Otherwise, set it.
- [x]  `echo "$USER"` should print the value of the USER variable.
    - [x]  `export test="-h -g -o"` then `ls $test`, should be treated as separate tokens/args
    - [x]  `export test=”many                 spaces”`
        - [x]  `echo $test` // will be separate tokens with one space
            
            `many spaces`
            
        - [x]  `echo "$test"` // spaces are literal
            
            `many                 spaces`
            
- [x]  **PASS?**

### cd

- [x]  Use the command cd to move the working directory and check if you are in the right directory with `/bin/ls`
- [x]  Repeat multiple times with working and not working cd
- [x]  Also, try '.' and '..' as arguments.
- [x]  `cd -`
- [x]  `cd ..`
- [x]  `cd .`
- [x]  **PASS?**

### pwd

- [x]  Use the command `pwd`.
- [x]  Repeat multiple times in different directories
- [x]  **PASS?**

### Relative Path

- [x]  Execute commands but this time use a relative path.
- [x]  Repeat multiple times in different directories with a complex relative path (lots of ..)
- [x]  **PASS?**

### Environment path

- [x]  Execute commands but this time without any path (ls, wc, awk and so forth).
- [x]  Unset the $PATH and ensure commands are not working anymore.
- [x]  Set the $PATH to a multiple directory value (directory1:directory2) and ensure that directories are checked in order from left to right
- [x]  **PASS?**

### Redirection

- [x]  Execute commands with redirections `<` and/or `>`
- [x]  Repeat multiple times with different commands and arguments and sometimes change `>` with `>>`
- [x]  Check if multiple tries of the same redirections fail.
- [x]  Test `<<` redirection (it doesn't have to update the history).
- [x]  `<<1 <<2 cat | <<3 <<4 cat | grep d` // only 4 is used
- [x]  `echo hello >1 >2 >3 >4` // cat 1 2 3 -> nothing cat 4 -> hello
- [x]  `echo "dalksdaj" >> test | cat test`
- [x]  **PASS?**

### Pipes

- [x]  Execute commands with pipes like 'cat file | grep bla | more'
- [x]  Repeat multiple times with different commands and arguments.
- [x]  Try some wrong commands like 'ls filethatdoesntexist | grep bla | more'
- [x]  Try to mix pipes and redirections.
- [x]  `1 | 2|3 | 4   | 5 | 6`
- [x]  `ls -a|grep mini | wc -l | cat > test.txt`
- [x]  `ls -a | grep mini | cat >> test.txt`
- [x]  `echo hello >> test | cat test`
- [x]  `echo hello > test | echo world > test2 | cat test`
- [x]  `echo hello >> test | cat test | echo world >> test2 | cat test2`
- [x]  `echo hello "|" | grep h`
- [x]  `echo hello "|" | grep "|" | wc -l > test`
- [x]  set file descriptor limit with ulimit -n 8 run `echo check | grep c | grep c | grep c | grep c | grep c | grep c | grep c`
- [ ]  `aaa|bbb|ccc|ddd|eee|fff|ggg` // spam several times in a row and see if it garbles the error message
ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | cat
ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls | ls
- [x]  **PASS?**

### Go Crazy and history

- [x]  Type a command line, then use ctrl-C and press "Enter". The buffer should be clean and there should be nothing left to execute.
- [x]  Can we navigate through history using Up and Down? Can we retry some command?
- [x]  Execute commands that should not work like 'dsbksdgbksdghsd'. Ensure minishell doesn't crash and prints an error.
- [x]  cat | cat | ls' should behave in a "normal way".
- [x]  Try to execute a long command with a ton of arguments.
- [x]  `echo "cat | ls" > test` → `./minishell < test` // won't need return for cat |
    
    don’t show prompt and exit.
    
- [x]  `echo "echo ciao" | ./minishell` // will print ciao
    
    don’t show prompt and exit.
    
- [ ]  missing heredoc/redir file
- [x]  `ls | << EOF` // redirect after pipe
- [x]  pipes and multiple HEREDOCS
- [x]  `echo hi >/non/hi.txt >2 >3` // No such file or directory error and 2&3 are not created
- [x]  `cat <<e"o"f` // if delim contains quotes, vars in heredoc aren't expanded, otherwise they are
- [x]  `cat | cat | cat | ls` // requires three returns to return the prompt, because of pipe buffering/SIGPIPE
- [x]  `cat | false -> echo $?` // should output 1 from false to prove this on bash `set -o pipefail` -> `cat | false` -> `echo $?` will output 141 (SIGPIPE) signal
- [x]  enter only spaces " " -> should update the history
- [x]  `cat /dev/urandom | head -n 5`
- [ ]  **PASS?**